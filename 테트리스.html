<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>테트리스</title>
<style>
  body {
    background: black;
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  canvas {
    background: #111;
    border: 3px solid #444;
  }
</style>
</head>
<body>

<audio id="bgm" src="music.mp3" loop autoplay></audio>

<canvas id="tetris" width="300" height="600"></canvas>

<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');

const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 30;

const COLORS = [
  null,
  '#00FFFF', // I - Cyan
  '#FFA500', // J - Orange
  '#0000FF', // L - Blue
  '#FFFF00', // O - Yellow
  '#00FF00', // S - Green
  '#800080', // T - Purple
  '#FF0000', // Z - Red
  '#FFFFFF'  // Special 3x3 block - White
];

// 블록 모양 (8가지 + 특수 3x3 블록)
const SHAPES = [
  [],
  [[1,1,1,1]],                // I
  [[2,0,0],[2,2,2]],          // J
  [[0,0,3],[3,3,3]],          // L
  [[4,4],[4,4]],              // O
  [[0,5,5],[5,5,0]],          // S
  [[0,6,0],[6,6,6]],          // T
  [[7,7,0],[0,7,7]],          // Z
  [                           // Special 3x3 block
    [8,8,8],
    [8,8,8],
    [8,8,8]
  ]
];

// 게임판 초기화
function createMatrix(w,h) {
  const matrix = [];
  for(let i=0; i<h; i++) {
    matrix.push(new Array(w).fill(0));
  }
  return matrix;
}

// 충돌 검사
function collide(arena, player) {
  const [m, o] = [player.matrix, player.pos];
  for(let y=0; y<m.length; y++) {
    for(let x=0; x<m[y].length; x++) {
      if(m[y][x] !== 0 &&
        (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0) {
          return true;
      }
    }
  }
  return false;
}

// 행 제거
function arenaSweep() {
  for(let y=arena.length-1; y>=0; y--) {
    if(arena[y].every(value => value !== 0)) {
      arena.splice(y, 1);
      arena.unshift(new Array(COLS).fill(0));
      y++; 
    }
  }
}

// 블록 회전
function rotate(matrix, dir) {
  for(let y=0; y<matrix.length; y++) {
    for(let x=0; x<y; x++) {
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if(dir > 0) matrix.forEach(row => row.reverse());
  else matrix.reverse();
}

// 현재 블록을 게임판에 합치기
function merge(arena, player) {
  player.matrix.forEach((row,y) => {
    row.forEach((value,x) => {
      if(value !== 0) {
        arena[y+player.pos.y][x+player.pos.x] = value;
      }
    });
  });
}

// 블록 그리기
function drawMatrix(matrix, offset, ghost=false) {
  matrix.forEach((row,y) => {
    row.forEach((value,x) => {
      if(value !== 0) {
        ctx.fillStyle = ghost ? 'rgba(255,255,255,0.3)' : COLORS[value];
        ctx.fillRect((x+offset.x)*BLOCK_SIZE, (y+offset.y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        ctx.strokeStyle = ghost ? 'rgba(255,255,255,0.1)' : '#000';
        ctx.lineWidth = 2;
        ctx.strokeRect((x+offset.x)*BLOCK_SIZE, (y+offset.y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      }
    });
  });
}

// 내려올 위치 (그림자)
function getGhostPos(player) {
  const ghost = {
    matrix: player.matrix,
    pos: {x: player.pos.x, y: player.pos.y}
  };
  while(!collide(arena, ghost)) {
    ghost.pos.y++;
  }
  ghost.pos.y--;
  return ghost.pos;
}

// 랜덤 블록 선택 (0~8)
function randomShape() {
  return SHAPES[Math.floor(Math.random() * SHAPES.length)];
}

const arena = createMatrix(COLS, ROWS);

const player = {
  pos: {x: 3, y: 0},
  matrix: randomShape()
};

let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;

function update(time=0) {
  const deltaTime = time - lastTime;
  lastTime = time;

  dropCounter += deltaTime;
  if(dropCounter > dropInterval) {
    player.pos.y++;
    if(collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      arenaSweep();
      player.matrix = randomShape();
      player.pos.y = 0;
      player.pos.x = Math.floor(COLS/2 - player.matrix[0].length/2);
      if(collide(arena, player)) {
        arena.forEach(row => row.fill(0));
        alert('게임 오버!');
      }
    }
    dropCounter = 0;
  }
  draw();
  requestAnimationFrame(update);
}

function draw() {
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawMatrix(arena, {x:0, y:0});

  // 그림자 표시
  const ghostPos = getGhostPos(player);
  drawMatrix(player.matrix, ghostPos, true);

  // 현재 블록 그리기
  drawMatrix(player.matrix, player.pos);
}

document.addEventListener('keydown', e => {
  if(e.key === 'ArrowLeft') {
    player.pos.x--;
    if(collide(arena, player)) player.pos.x++;
  } else if(e.key === 'ArrowRight') {
    player.pos.x++;
    if(collide(arena, player)) player.pos.x--;
  } else if(e.key === 'ArrowDown') {
    player.pos.y++;
    if(collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      arenaSweep();
      player.matrix = randomShape();
      player.pos.y = 0;
      player.pos.x = Math.floor(COLS/2 - player.matrix[0].length/2);
      if(collide(arena, player)) {
        arena.forEach(row => row.fill(0));
        alert('게임 오버!');
      }
    }
    dropCounter = 0;
  } else if(e.key === 'ArrowUp') {
    rotate(player.matrix, 1);
    if(collide(arena, player)) rotate(player.matrix, -1);
  }
});

// 초기 블록 위치 맞추기
player.pos.x = Math.floor(COLS/2 - player.matrix[0].length/2);
update();

</script>

</body>
</html>





